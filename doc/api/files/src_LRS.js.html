<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src&#x2F;LRS.js - TinCanJS</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.5.1&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.5.1&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="http:&#x2F;&#x2F;cdn4.tincanapi.com&#x2F;wp-content&#x2F;themes&#x2F;tincanapi&#x2F;images&#x2F;logo.png" title="TinCanJS"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/TinCan.html">TinCan</a></li>
            
                <li><a href="..&#x2F;classes/TinCan.Activity.html">TinCan.Activity</a></li>
            
                <li><a href="..&#x2F;classes/TinCan.ActivityDefinition.html">TinCan.ActivityDefinition</a></li>
            
                <li><a href="..&#x2F;classes/TinCan.Agent.html">TinCan.Agent</a></li>
            
                <li><a href="..&#x2F;classes/TinCan.Context.html">TinCan.Context</a></li>
            
                <li><a href="..&#x2F;classes/TinCan.LRS.html">TinCan.LRS</a></li>
            
                <li><a href="..&#x2F;classes/TinCan.Result.html">TinCan.Result</a></li>
            
                <li><a href="..&#x2F;classes/TinCan.Score.html">TinCan.Score</a></li>
            
                <li><a href="..&#x2F;classes/TinCan.State.html">TinCan.State</a></li>
            
                <li><a href="..&#x2F;classes/TinCan.Statement.html">TinCan.Statement</a></li>
            
                <li><a href="..&#x2F;classes/TinCan.Verb.html">TinCan.Verb</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/TinCan.html">TinCan</a></li>
            
                <li><a href="..&#x2F;modules/TinCan.Activity.html">TinCan.Activity</a></li>
            
                <li><a href="..&#x2F;modules/TinCan.ActivityDefinition.html">TinCan.ActivityDefinition</a></li>
            
                <li><a href="..&#x2F;modules/TinCan.Agent.html">TinCan.Agent</a></li>
            
                <li><a href="..&#x2F;modules/TinCan.Context.html">TinCan.Context</a></li>
            
                <li><a href="..&#x2F;modules/TinCan.LRS.html">TinCan.LRS</a></li>
            
                <li><a href="..&#x2F;modules/TinCan.Result.html">TinCan.Result</a></li>
            
                <li><a href="..&#x2F;modules/TinCan.Score.html">TinCan.Score</a></li>
            
                <li><a href="..&#x2F;modules/TinCan.State.html">TinCan.State</a></li>
            
                <li><a href="..&#x2F;modules/TinCan.Statement.html">TinCan.Statement</a></li>
            
                <li><a href="..&#x2F;modules/TinCan.Utils.html">TinCan.Utils</a></li>
            
                <li><a href="..&#x2F;modules/TinCan.Verb.html">TinCan.Verb</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src&#x2F;LRS.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;*
    Copyright 2012 Rustici Software

    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http:&#x2F;&#x2F;www.apache.org&#x2F;licenses&#x2F;LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*&#x2F;

&#x2F;**
TinCan client library

@module TinCan
@submodule TinCan.LRS
**&#x2F;
(function () {
    &quot;use strict&quot;;
    var IE = &quot;ie&quot;,

    &#x2F;**
    @class TinCan.LRS
    @constructor
    *&#x2F;
    LRS = TinCan.LRS = function (cfg) {
        this.log(&quot;constructor&quot;);

        &#x2F;**
        @property endpoint
        @type String
        *&#x2F;
        this.endpoint = null;

        &#x2F;**
        @property version
        @type String
        *&#x2F;
        this.version = null;

        &#x2F;**
        @property auth
        @type String
        *&#x2F;
        this.auth = null;

        &#x2F;**
        @property allowFail
        @type Boolean
        @default true
        *&#x2F;
        this.allowFail = true;

        &#x2F;**
        @property extended
        @type Object
        *&#x2F;
        this.extended = null;

        &#x2F;**
        @property _requestMode
        @type String
        @default &quot;native&quot;
        @private
        *&#x2F;
        this._requestMode = &quot;native&quot;;

        this.init(cfg);
    };
    LRS.prototype = {
        &#x2F;**
        @property LOG_SRC
        *&#x2F;
        LOG_SRC: &quot;LRS&quot;,

        &#x2F;**
        @method log
        *&#x2F;
        log: TinCan.prototype.log,

        &#x2F;**
        @method init
        *&#x2F;
        init: function (cfg) {
            &#x2F;*jslint regexp: true *&#x2F;
            this.log(&quot;init&quot;);

            var urlParts,
                schemeMatches,
                isXD,
                env = TinCan.environment()
            ;

            cfg = cfg || {};

            if (! cfg.hasOwnProperty(&quot;endpoint&quot;)) {
                if (env.isBrowser) {
                    alert(&quot;[error] LRS invalid: no endpoint&quot;);
                }
                throw {
                    code: 3,
                    mesg: &quot;LRS invalid: no endpoint&quot;
                };
            }
            this.endpoint = cfg.endpoint;

            if (cfg.hasOwnProperty(&quot;allowFail&quot;)) {
                this.allowFail = cfg.allowFail;
            }

            if (cfg.hasOwnProperty(&quot;auth&quot;)) {
                this.auth = cfg.auth;
            }

            urlParts = cfg.endpoint.toLowerCase().match(&#x2F;([A-Za-z]+:)\&#x2F;\&#x2F;([^:\&#x2F;]+):?(\d+)?(\&#x2F;.*)?$&#x2F;);

            if (env.isBrowser) {
                &#x2F;&#x2F;
                &#x2F;&#x2F; determine whether this is a cross domain request,
                &#x2F;&#x2F; if it is then if we are in IE check that the schemes
                &#x2F;&#x2F; match to see if we should be able to talk to the LRS
                &#x2F;&#x2F;
                schemeMatches = location.protocol.toLowerCase() === urlParts[1];
                isXD = (
                    &#x2F;&#x2F; is same scheme?
                    ! schemeMatches

                    &#x2F;&#x2F; is same host?
                    || location.hostname.toLowerCase() !== urlParts[2]

                    &#x2F;&#x2F; is same port?
                    || location.port !== (
                        urlParts[3] !== null ? urlParts[3] : (urlParts[1] === &quot;http:&quot; ? &quot;80&quot; : &quot;443&quot;)
                    )
                );
                if (isXD &amp;&amp; env.isIE) {
                    if (schemeMatches) {
                        this._requestMode = IE;
                    }
                    else {
                        if (cfg.allowFail) {
                            alert(&quot;[warning] LRS invalid: cross domain request for differing scheme in IE&quot;);
                        }
                        else {
                            alert(&quot;[error] LRS invalid: cross domain request for differing scheme in IE&quot;);
                            throw {
                                code: 2,
                                mesg: &quot;LRS invalid: cross domain request for differing scheme in IE&quot;
                            };
                        }
                    }
                }
            }
            else {
                this.log(&quot;Unrecognized environment not supported: &quot; + env);
            }

            if (typeof cfg.version !== &quot;undefined&quot;) {
                this.version = cfg.version;
            }
        },

        &#x2F;**
        @method sendRequest
        @param {Object} [cfg] Configuration for request
            @param {String} [cfg.url] URL portion to add to endpoint
            @param {String} [cfg.method] GET, PUT, POST, etc.
            @param {Object} [cfg.params] Parameters to set on the querystring
            @param {String} [cfg.data] String of body content
            @param {Function} [cfg.callback] Function to run at completion
            @param {Boolean} [cfg.ignore404] Whether 404 status codes should be ignored
            @param {Object} [cfg.headers] Additional headers to set in the request
        *&#x2F;
        sendRequest: function (cfg) {
            this.log(&quot;sendRequest&quot;);
            var xhr,
                finished = false,
                location = window.location,
                fullUrl = this.endpoint + cfg.url,
                headers = {},
                data,
                requestCompleteResult,
                until,
                prop,
                pairs = [],
                self = this
            ;

            &#x2F;&#x2F; add extended LMS-specified values to the params
            if (this.extended !== null) {
                for (prop in this.extended) {
                    if (this.extended.hasOwnProperty(prop)) {
                        &#x2F;&#x2F; TODO: don&#x27;t overwrite cfg.params value
                        if (this.extended[prop] !== null &amp;&amp; this.extended[prop].length &gt; 0) {
                            cfg.params[prop] = this.extended[prop];
                        }
                    }
                }
            }

            &#x2F;&#x2F; consolidate headers
            headers[&quot;Content-Type&quot;] = &quot;application&#x2F;json&quot;;
            headers.Authorization = this.auth;
            if (this.version !== &quot;0.90&quot;) {
                headers[&quot;X-Experience-API-Version&quot;] = this.version;
            }

            for (prop in cfg.headers) {
                if (cfg.headers.hasOwnProperty(prop)) {
                    headers[prop] = cfg.headers[prop];
                }
            }

            if (this._requestMode === &quot;native&quot;) {
                this.log(&quot;sendRequest using XMLHttpRequest&quot;);

                for (prop in cfg.params) {
                    if (cfg.params.hasOwnProperty(prop)) {
                        pairs.push(prop + &quot;=&quot; + encodeURIComponent(cfg.params[prop]));
                    }
                }
                if (pairs.length &gt; 0) {
                    fullUrl += &quot;?&quot; + pairs.join(&quot;&amp;&quot;);
                }

                xhr = new XMLHttpRequest();
                xhr.open(cfg.method, fullUrl, cfg.callback !== undefined);
                for (prop in headers) {
                    if (headers.hasOwnProperty(prop)) {
                        xhr.setRequestHeader(prop, headers[prop]);
                    }
                }
                data = cfg.data;
            }
            else if (this._requestMode === IE) {
                this.log(&quot;sendRequest using XDomainRequest&quot;);

                &#x2F;&#x2F; method has to go on querystring, and nothing else,
                &#x2F;&#x2F; and the actual method is then always POST
                fullUrl += &quot;?method=&quot; + cfg.method;

                &#x2F;&#x2F; params end up in the body
                for (prop in cfg.params) {
                    if (cfg.params.hasOwnProperty(prop)) {
                        pairs.push(prop + &quot;=&quot; + encodeURIComponent(headers[prop]));
                    }
                }

                &#x2F;&#x2F; headers go into form data
                for (prop in headers) {
                    if (headers.hasOwnProperty(prop)) {
                        pairs.push(prop + &quot;=&quot; + encodeURIComponent(headers[prop]));
                    }
                }

                &#x2F;&#x2F; the original data is repackaged as &quot;content&quot; form var
                if (cfg.data !== null) {
                    pairs.push(&quot;content=&quot; + encodeURIComponent(cfg.data));
                }

                data = pairs.join(&quot;&amp;&quot;);

                xhr = new XDomainRequest ();
                xhr.open(&quot;POST&quot;, fullUrl);
            }
            else {
                this.log(&quot;sendRequest unrecognized _requestMode: &quot; + this._requestMode);
            }

            &#x2F;&#x2F;Setup request callback
            function requestComplete () {
                self.log(&quot;requestComplete: &quot; + finished + &quot;, xhr.status: &quot; + xhr.status);
                var notFoundOk;

                if (! finished) {
                    &#x2F;&#x2F; may be in sync or async mode, using XMLHttpRequest or IE XDomainRequest, onreadystatechange or
                    &#x2F;&#x2F; onload or both might fire depending upon browser, just covering all bases with event hooks and
                    &#x2F;&#x2F; using &#x27;finished&#x27; flag to avoid triggering events multiple times
                    finished = true;

                    notFoundOk = (cfg.ignore404 &amp;&amp; xhr.status === 404);
                    if (xhr.status === undefined || (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 400) || notFoundOk) {
                        if (cfg.callback) {
                            cfg.callback(xhr);
                        }
                        else {
                            requestCompleteResult = xhr;
                            return xhr;
                        }
                    }
                    else {
                        &#x2F;&#x2F; Alert all errors except cancelled XHR requests
                        if (xhr.status &gt; 0) {
                            alert(&quot;[warning] There was a problem communicating with the Learning Record Store. (&quot; + xhr.status + &quot; | &quot; + xhr.responseText+ &quot;)&quot;);
                        }
                        return xhr;
                    }
                }
                else {
                    return requestCompleteResult;
                }
            }

            xhr.onreadystatechange = function () {
                if (xhr.readyState === 4) {
                    requestComplete();
                }
            };

            xhr.onload = requestComplete;
            xhr.onerror = requestComplete;

            xhr.send(data);

            if (! cfg.callback) {
                &#x2F;&#x2F; synchronous
                if (this._requestMode === IE) {
                    &#x2F;&#x2F; synchronous call in IE, with no synchronous mode available
                    until = 1000 + Date.now();
                    this.log(&quot;sendRequest: until: &quot; + until + &quot;, finished: &quot; + finished);

                    while (Date.now() &lt; until &amp;&amp; ! finished) {
                        &#x2F;&#x2F;this.log(&quot;calling __delay&quot;);
                        this.__delay();
                    }
                }
                return requestComplete();
            }
        },

        &#x2F;**
        Save a statement, when used from a browser sends to the endpoint using the RESTful interface.
        Use a callback to make the call asynchronous.

        @method saveStatement
        @param {Object} TinCan.Statement to send
        @param {Object} [cfg] Configuration used when saving
            @param {Function} [cfg.callback] Callback to execute on completion
        *&#x2F;
        saveStatement: function (stmt, cfg) {
            this.log(&quot;saveStatement&quot;);
            var requestCfg;

            &#x2F;&#x2F; TODO: it would be better to make a subclass that knows
            &#x2F;&#x2F;       its own environment and just implements the protocol
            &#x2F;&#x2F;       that it needs to
            if (TinCan.environment().isBrowser) {
                requestCfg = {
                    url: &quot;statements&quot;,
                    method: &quot;PUT&quot;,
                    params: {
                        statementId: stmt.id
                    },
                    data: JSON.stringify(stmt.asVersion( this.version ))
                };
                if (typeof cfg.callback !== &quot;undefined&quot;) {
                    requestCfg.callback = cfg.callback;
                }

                this.sendRequest(requestCfg);
            }
            else {
                this.log(&quot;error: environment not implemented&quot;);
            }
        },

        &#x2F;**
        Retrieve a statement, when used from a browser sends to the endpoint using the RESTful interface.

        @method retrieveStatement
        @param {String} ID of statement to retrieve
        @param {Object} [cfg] Configuration options
            @param {Function} [cfg.callback] Callback to execute on completion
        @return {Object} TinCan.Statement retrieved
        *&#x2F;
        retrieveStatement: function (stmtId, cfg) {
            this.log(&quot;retrieveStatement&quot;);
            var callbackWrapper;

            callbackWrapper = function () {
                var statement;

                cfg.callback(statement);
            };

            &#x2F;&#x2F; TODO: it would be better to make a subclass that knows
            &#x2F;&#x2F;       its own environment and just implements the protocol
            &#x2F;&#x2F;       that it needs to
            if (TinCan.environment().isBrowser) {
                this.sendRequest(
                    {
                        url: &quot;statements&quot;,
                        method: &quot;GET&quot;,
                        params: {
                            statementId: stmtId
                        }
                        &#x2F;&#x2F;callback: cfg.callback
                    }
                );
            }
            else {
                this.log(&quot;error: environment not implemented&quot;);
            }
        },

        &#x2F;**
        Save a set of statements, when used from a browser sends to the endpoint using the RESTful interface.
        Use a callback to make the call asynchronous.

        @method saveStatements
        @param {Array} Array of statements or objects convertable to statements
        @param {Object} [cfg] Configuration used when saving
            @param {Function} [cfg.callback] Callback to execute on completion
        *&#x2F;
        saveStatements: function (stmts, cfg) {
            this.log(&quot;saveStatements&quot;);
            var versionedStatements = [],
                requestCfg,
                i
            ;

            cfg = cfg || {};

            if (stmts.length &gt; 0) {
                for (i = 0; i &lt; stmts.length; i += 1) {
                    versionedStatements.push(
                        stmts[i].asVersion( this.version )
                    );
                }

                &#x2F;&#x2F; TODO: it would be better to make a subclass that knows
                &#x2F;&#x2F;       its own environment and just implements the protocol
                &#x2F;&#x2F;       that it needs to
                if (TinCan.environment().isBrowser) {
                    requestCfg = {
                        url: &quot;statements&quot;,
                        method: &quot;POST&quot;,
                        data: JSON.stringify(versionedStatements)
                    };
                    if (typeof cfg.callback !== &quot;undefined&quot;) {
                        requestCfg.callback = cfg.callback;
                    }

                    this.sendRequest(requestCfg);
                }
                else {
                    this.log(&quot;error: environment not implemented&quot;);
                }
            }
        },

        &#x2F;**
        Fetch a set of statements, when used from a browser sends to the endpoint using the
        RESTful interface.  Use a callback to make the call asynchronous.

        @method queryStatements
        @param {Object} [cfg] Configuration used to query
            @param {Function} [cfg.callback] Callback to execute on completion
        @return {Array} Array of statements
        *&#x2F;
        queryStatements: function (cfg) {
            this.log(&quot;queryStatements&quot;);
            var objectProps = [&quot;actor&quot;, &quot;verb&quot;, &quot;activity&quot;],
                stringProps = [&quot;registration&quot;, &quot;sparse&quot;],
                requestParams = {},
                requestCfg = {},
                requestResult,
                i
            ;

            &#x2F;&#x2F; TODO: it would be better to make a subclass that knows
            &#x2F;&#x2F;       its own environment and just implements the protocol
            &#x2F;&#x2F;       that it needs to
            if (! TinCan.environment().isBrowser) {
                this.log(&quot;error: environment not implemented&quot;);
                return;
            }

            cfg = cfg || {};
            cfg.params = cfg.params || {};

            for (i = 0; i &lt; objectProps.length; i += 1) {
                if (typeof cfg.params[objectProps[i]] !== &quot;undefined&quot;) {
                    requestParams[objectProps[i]] = JSON.stringify(cfg.params[objectProps[i]].asVersion(this.version));
                }
            }

            for (i = 0; i &lt; stringProps.length; i += 1) {
                if (typeof cfg.params[stringProps[i]] !== &quot;undefined&quot;) {
                    requestParams[stringProps[i]] = cfg.params[stringProps[i]];
                }
            }

            requestCfg = {
                url: &quot;statements&quot;,
                method: &quot;GET&quot;,
                params: requestParams
            };
            if (typeof cfg.callback !== &quot;undefined&quot;) {
                requestCfg.callback = cfg.callback;
            }

            requestResult = this.sendRequest(requestCfg);

            &#x2F;&#x2F; TODO: this seems like a bad interface decision
            return requestResult.responseText;
        },

        &#x2F;**
        Retrieve a state value, when used from a browser sends to the endpoint using the RESTful interface.

        @method retrieveState
        @param {String} key Key of state to retrieve
        @param {Object} cfg Configuration options
            @param {Object} activity TinCan.Activity
            @param {Object} actor TinCan.Actor
            @param {String} [registration] Registration
            @param {Function} [cfg.callback] Callback to execute on completion
        @return {Object} TinCan.State retrieved
        *&#x2F;
        retrieveState: function (key, cfg) {
            this.log(&quot;retrieveState&quot;);
            var requestParams = {},
                requestCfg = {},
                requestResult
            ;

            &#x2F;&#x2F; TODO: it would be better to make a subclass that knows
            &#x2F;&#x2F;       its own environment and just implements the protocol
            &#x2F;&#x2F;       that it needs to
            if (! TinCan.environment().isBrowser) {
                this.log(&quot;error: environment not implemented&quot;);
                return;
            }

            requestParams = {
                stateId: key,
                activityId: cfg.activity.id,
                actor: JSON.stringify(cfg.actor.asVersion(this.version))
            };
            if (typeof cfg.registration !== &quot;undefined&quot;) {
                requestParams.registrationId = cfg.registration;
            }

            requestCfg = {
                url: &quot;activities&#x2F;state&quot;,
                method: &quot;GET&quot;,
                params: requestParams
            };
            if (typeof cfg.callback !== &quot;undefined&quot;) {
                requestCfg.callback = cfg.callback;
            }

            requestResult = this.sendRequest(requestCfg);

            &#x2F;&#x2F; TODO: need to convert into a TinCan.State object
            &#x2F;&#x2F; TODO: this seems like a bad interface decision
            return requestResult.responseText;
        },

        &#x2F;**
        Save a state value, when used from a browser sends to the endpoint using the RESTful interface.

        @method saveState
        @param {String} key Key of state to retrieve
        @param {Object} cfg Configuration options
            @param {Object} activity TinCan.Activity
            @param {Object} actor TinCan.Actor
            @param {String} registration Registration
            @param {Function} [cfg.callback] Callback to execute on completion
        *&#x2F;
        saveState: function (key, val, cfg) {
            this.log(&quot;saveState&quot;);
            var requestParams,
                requestCfg,
                requestResult
            ;

            &#x2F;&#x2F; TODO: it would be better to make a subclass that knows
            &#x2F;&#x2F;       its own environment and just implements the protocol
            &#x2F;&#x2F;       that it needs to
            if (! TinCan.environment().isBrowser) {
                this.log(&quot;error: environment not implemented&quot;);
                return;
            }

            if (typeof val === &quot;object&quot;) {
                val = JSON.stringify(val);
            }

            requestParams = {
                stateId: key,
                activityId: cfg.activity.id,
                actor: JSON.stringify(cfg.actor.asVersion(this.version))
            };
            if (typeof cfg.registration !== &quot;undefined&quot;) {
                requestParams.registrationId = cfg.registration;
            }

            requestCfg = {
                url: &quot;activities&#x2F;state&quot;,
                method: &quot;PUT&quot;,
                params: requestParams,
                data: val
            };
            if (typeof cfg.callback !== &quot;undefined&quot;) {
                requestCfg.callback = cfg.callback;
            }

            requestResult = this.sendRequest(requestCfg);

            &#x2F;&#x2F; TODO: need to convert into a TinCan.State object
            &#x2F;&#x2F; TODO: this seems like a bad interface decision
            return requestResult.responseText;
        },

        &#x2F;**
        Drop a state value or all of the state, when used from a browser sends to the endpoint using the RESTful interface.

        @method dropState
        @param {String|null} key Key of state to delete, or null for all
        @param {Object} cfg Configuration options
            @param {Object} activity TinCan.Activity
            @param {Object} actor TinCan.Actor
            @param {String} [registration] Registration
            @param {Function} [cfg.callback] Callback to execute on completion
        *&#x2F;
        dropState: function (key, cfg) {
            this.log(&quot;dropState&quot;);
            var requestParams = {},
                requestCfg = {}
            ;

            &#x2F;&#x2F; TODO: it would be better to make a subclass that knows
            &#x2F;&#x2F;       its own environment and just implements the protocol
            &#x2F;&#x2F;       that it needs to
            if (! TinCan.environment().isBrowser) {
                this.log(&quot;error: environment not implemented&quot;);
                return;
            }

            requestParams = {
                activityId: cfg.activity.id,
                actor: JSON.stringify(cfg.actor.asVersion(this.version))
            };
            if (key !== null) {
                requestParams.stateId = key;
            }
            if (typeof cfg.registration !== &quot;undefined&quot;) {
                requestParams.registrationId = cfg.registration;
            }

            requestCfg = {
                url: &quot;activities&#x2F;state&quot;,
                method: &quot;DELETE&quot;,
                params: requestParams
            };
            if (typeof cfg.callback !== &quot;undefined&quot;) {
                requestCfg.callback = cfg.callback;
            }

            this.sendRequest(requestCfg);
        },

        &#x2F;**
        Retrieve an activity profile value, when used from a browser sends to the endpoint using the RESTful interface.

        @method retrieveActivityProfile
        @param {String} key Key of activity profile to retrieve
        @param {Object} cfg Configuration options
            @param {Object} activity TinCan.Activity
            @param {Object} actor TinCan.Actor
            @param {String} [registration] Registration
            @param {Function} [cfg.callback] Callback to execute on completion
        @return {Object} Value retrieved
        *&#x2F;
        retrieveActivityProfile: function (key, cfg) {
            this.log(&quot;retrieveActivityProfile&quot;);
            var requestCfg = {},
                requestResult
            ;

            &#x2F;&#x2F; TODO: it would be better to make a subclass that knows
            &#x2F;&#x2F;       its own environment and just implements the protocol
            &#x2F;&#x2F;       that it needs to
            if (! TinCan.environment().isBrowser) {
                this.log(&quot;error: environment not implemented&quot;);
                return;
            }

            requestCfg = {
                url: &quot;activities&#x2F;profile&quot;,
                method: &quot;GET&quot;,
                params: {
                    profileId: key,
                    activityId: cfg.activity.id
                }
            };
            if (typeof cfg.callback !== &quot;undefined&quot;) {
                requestCfg.callback = cfg.callback;
            }

            requestResult = this.sendRequest(requestCfg);

            &#x2F;&#x2F; TODO: this seems like a bad interface decision
            return requestResult.responseText;
        },

        &#x2F;**
        Save an activity profile value, when used from a browser sends to the endpoint using the RESTful interface.

        @method saveActivityProfile
        @param {String} key Key of activity profile to retrieve
        @param {Object} cfg Configuration options
            @param {Object} activity TinCan.Activity
            @param {Function} [cfg.callback] Callback to execute on completion
        *&#x2F;
        saveActivityProfile: function (key, val, cfg) {
            this.log(&quot;saveActivityProfile&quot;);
            var requestCfg;

            &#x2F;&#x2F; TODO: it would be better to make a subclass that knows
            &#x2F;&#x2F;       its own environment and just implements the protocol
            &#x2F;&#x2F;       that it needs to
            if (! TinCan.environment().isBrowser) {
                this.log(&quot;error: environment not implemented&quot;);
                return;
            }

            if (typeof val === &quot;object&quot;) {
                val = JSON.stringify(val);
            }

            requestCfg = {
                url: &quot;activities&#x2F;profile&quot;,
                method: &quot;PUT&quot;,
                params: {
                    profileId: key,
                    activityId: cfg.activity.id
                },
                data: val
            };
            if (typeof cfg.callback !== &quot;undefined&quot;) {
                requestCfg.callback = cfg.callback;
            }

            this.sendRequest(requestCfg);
        },

        &#x2F;**
        Drop an activity profile value or all of the activity profile, when used from a browser sends to the endpoint using the RESTful interface.

        @method dropState
        @param {String|null} key Key of activity profile to delete, or null for all
        @param {Object} cfg Configuration options
            @param {Object} activity TinCan.Activity
            @param {Function} [cfg.callback] Callback to execute on completion
        *&#x2F;
        dropActivityProfile: function (key, cfg) {
            this.log(&quot;dropActivityProfile&quot;);
            var requestParams = {},
                requestCfg = {}
            ;

            &#x2F;&#x2F; TODO: it would be better to make a subclass that knows
            &#x2F;&#x2F;       its own environment and just implements the protocol
            &#x2F;&#x2F;       that it needs to
            if (! TinCan.environment().isBrowser) {
                this.log(&quot;error: environment not implemented&quot;);
                return;
            }

            requestParams = {
                activityId: cfg.activity.id
            };
            if (key !== null) {
                requestParams.profileId = key;
            }

            requestCfg = {
                url: &quot;activities&#x2F;profile&quot;,
                method: &quot;DELETE&quot;,
                params: requestParams
            };
            if (typeof cfg.callback !== &quot;undefined&quot;) {
                requestCfg.callback = cfg.callback;
            }

            this.sendRequest(requestCfg);
        },

        &#x2F;**
        @method __delay
        @private
        *&#x2F;
        __delay: function () {
            &#x2F;&#x2F;
            &#x2F;&#x2F; use a synchronous request to the current location to allow the browser
            &#x2F;&#x2F; to yield to the asynchronous request&#x27;s events but still block in the
            &#x2F;&#x2F; outer loop to make it seem synchronous to the end user
            &#x2F;&#x2F;
            &#x2F;&#x2F; removing this made the while loop too tight to allow the asynchronous
            &#x2F;&#x2F; events through to get handled so that the response was correctly handled
            &#x2F;&#x2F;
            var xhr = new XMLHttpRequest (),
                url = window.location + &quot;?forcenocache=&quot; + TinCan.Utils.getUUID()
            ;
            xhr.open(&quot;GET&quot;, url, false);
            xhr.send(null);
        }
    };
}());

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
