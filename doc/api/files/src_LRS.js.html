<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src&#x2F;LRS.js - TinCanJS</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.7.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.7.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="http:&#x2F;&#x2F;cdn4.tincanapi.com&#x2F;wp-content&#x2F;themes&#x2F;tincanapi&#x2F;images&#x2F;logo.png" title="TinCanJS"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1.3</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/TinCan.html">TinCan</a></li>
            
                <li><a href="..&#x2F;classes/TinCan.Activity.html">TinCan.Activity</a></li>
            
                <li><a href="..&#x2F;classes/TinCan.ActivityDefinition.html">TinCan.ActivityDefinition</a></li>
            
                <li><a href="..&#x2F;classes/TinCan.ActivityProfile.html">TinCan.ActivityProfile</a></li>
            
                <li><a href="..&#x2F;classes/TinCan.Agent.html">TinCan.Agent</a></li>
            
                <li><a href="..&#x2F;classes/TinCan.AgentAccount.html">TinCan.AgentAccount</a></li>
            
                <li><a href="..&#x2F;classes/TinCan.Context.html">TinCan.Context</a></li>
            
                <li><a href="..&#x2F;classes/TinCan.Group.html">TinCan.Group</a></li>
            
                <li><a href="..&#x2F;classes/TinCan.InteractionComponent.html">TinCan.InteractionComponent</a></li>
            
                <li><a href="..&#x2F;classes/TinCan.LRS.html">TinCan.LRS</a></li>
            
                <li><a href="..&#x2F;classes/TinCan.Result.html">TinCan.Result</a></li>
            
                <li><a href="..&#x2F;classes/TinCan.Score.html">TinCan.Score</a></li>
            
                <li><a href="..&#x2F;classes/TinCan.State.html">TinCan.State</a></li>
            
                <li><a href="..&#x2F;classes/TinCan.Statement.html">TinCan.Statement</a></li>
            
                <li><a href="..&#x2F;classes/TinCan.StatementRef.html">TinCan.StatementRef</a></li>
            
                <li><a href="..&#x2F;classes/TinCan.StatementsResult.html">TinCan.StatementsResult</a></li>
            
                <li><a href="..&#x2F;classes/TinCan.SubStatement.html">TinCan.SubStatement</a></li>
            
                <li><a href="..&#x2F;classes/TinCan.Utils.html">TinCan.Utils</a></li>
            
                <li><a href="..&#x2F;classes/TinCan.Verb.html">TinCan.Verb</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/TinCan.html">TinCan</a></li>
            
                <li><a href="..&#x2F;modules/TinCan.Activity.html">TinCan.Activity</a></li>
            
                <li><a href="..&#x2F;modules/TinCan.ActivityDefinition.html">TinCan.ActivityDefinition</a></li>
            
                <li><a href="..&#x2F;modules/TinCan.ActivityProfile.html">TinCan.ActivityProfile</a></li>
            
                <li><a href="..&#x2F;modules/TinCan.Agent.html">TinCan.Agent</a></li>
            
                <li><a href="..&#x2F;modules/TinCan.AgentAccount.html">TinCan.AgentAccount</a></li>
            
                <li><a href="..&#x2F;modules/TinCan.Context.html">TinCan.Context</a></li>
            
                <li><a href="..&#x2F;modules/TinCan.Group.html">TinCan.Group</a></li>
            
                <li><a href="..&#x2F;modules/TinCan.InteractionComponent.html">TinCan.InteractionComponent</a></li>
            
                <li><a href="..&#x2F;modules/TinCan.LRS.html">TinCan.LRS</a></li>
            
                <li><a href="..&#x2F;modules/TinCan.Result.html">TinCan.Result</a></li>
            
                <li><a href="..&#x2F;modules/TinCan.Score.html">TinCan.Score</a></li>
            
                <li><a href="..&#x2F;modules/TinCan.State.html">TinCan.State</a></li>
            
                <li><a href="..&#x2F;modules/TinCan.Statement.html">TinCan.Statement</a></li>
            
                <li><a href="..&#x2F;modules/TinCan.StatementRef.html">TinCan.StatementRef</a></li>
            
                <li><a href="..&#x2F;modules/TinCan.StatementsResult.html">TinCan.StatementsResult</a></li>
            
                <li><a href="..&#x2F;modules/TinCan.SubStatement.html">TinCan.SubStatement</a></li>
            
                <li><a href="..&#x2F;modules/TinCan.Utils.html">TinCan.Utils</a></li>
            
                <li><a href="..&#x2F;modules/TinCan.Verb.html">TinCan.Verb</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: src&#x2F;LRS.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;*
    Copyright 2012 Rustici Software

    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http:&#x2F;&#x2F;www.apache.org&#x2F;licenses&#x2F;LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*&#x2F;

&#x2F;**
TinCan client library

@module TinCan
@submodule TinCan.LRS
**&#x2F;
(function () {
    &quot;use strict&quot;;
    var XDR = &quot;xdr&quot;,
        NATIVE = &quot;native&quot;,

    &#x2F;**
    @class TinCan.LRS
    @constructor
    *&#x2F;
    LRS = TinCan.LRS = function (cfg) {
        this.log(&quot;constructor&quot;);

        &#x2F;**
        @property endpoint
        @type String
        *&#x2F;
        this.endpoint = null;

        &#x2F;**
        @property version
        @type String
        *&#x2F;
        this.version = null;

        &#x2F;**
        @property auth
        @type String
        *&#x2F;
        this.auth = null;

        &#x2F;**
        @property allowFail
        @type Boolean
        @default true
        *&#x2F;
        this.allowFail = true;

        &#x2F;**
        @property alertOnRequestFailure
        @type Boolean
        @default true
        *&#x2F;
        this.alertOnRequestFailure = true;

        &#x2F;**
        @property extended
        @type Object
        *&#x2F;
        this.extended = null;

        &#x2F;**
        @property _requestMode
        @type String
        @default &quot;native&quot;
        @private
        *&#x2F;
        this._requestMode = NATIVE;

        this.init(cfg);
    };
    LRS.prototype = {
        &#x2F;**
        @property LOG_SRC
        *&#x2F;
        LOG_SRC: &quot;LRS&quot;,

        &#x2F;**
        @method log
        *&#x2F;
        log: TinCan.prototype.log,

        &#x2F;**
        @method init
        *&#x2F;
        init: function (cfg) {
            &#x2F;*jslint regexp: true *&#x2F;
            this.log(&quot;init&quot;);

            var urlParts,
                schemeMatches,
                isXD,
                env = TinCan.environment()
            ;

            cfg = cfg || {};

            if (! cfg.hasOwnProperty(&quot;endpoint&quot;)) {
                if (env.isBrowser &amp;&amp; this.alertOnRequestFailure) {
                    alert(&quot;[error] LRS invalid: no endpoint&quot;);
                }
                throw {
                    code: 3,
                    mesg: &quot;LRS invalid: no endpoint&quot;
                };
            }

            this.endpoint = cfg.endpoint;

            if (cfg.hasOwnProperty(&quot;allowFail&quot;)) {
                this.allowFail = cfg.allowFail;
            }

            if (cfg.hasOwnProperty(&quot;auth&quot;)) {
                this.auth = cfg.auth;
            }

            if (cfg.hasOwnProperty(&quot;extended&quot;)) {
                this.extended = cfg.extended;
            }

            urlParts = cfg.endpoint.toLowerCase().match(&#x2F;([A-Za-z]+:)\&#x2F;\&#x2F;([^:\&#x2F;]+):?(\d+)?(\&#x2F;.*)?$&#x2F;);

            if (env.isBrowser) {
                &#x2F;&#x2F;
                &#x2F;&#x2F; determine whether this is a cross domain request,
                &#x2F;&#x2F; whether our browser has CORS support at all, and then
                &#x2F;&#x2F; if it does then if we are in IE with XDR only check that
                &#x2F;&#x2F; the schemes match to see if we should be able to talk to
                &#x2F;&#x2F; the LRS
                &#x2F;&#x2F;
                schemeMatches = location.protocol.toLowerCase() === urlParts[1];
                isXD = (
                    &#x2F;&#x2F; is same scheme?
                    ! schemeMatches

                    &#x2F;&#x2F; is same host?
                    || location.hostname.toLowerCase() !== urlParts[2]

                    &#x2F;&#x2F; is same port?
                    || location.port !== (
                        urlParts[3] !== null ? urlParts[3] : (urlParts[1] === &quot;http:&quot; ? &quot;80&quot; : &quot;443&quot;)
                    )
                );
                if (isXD) {
                    if (env.hasCORS) {
                        if (env.useXDR &amp;&amp; schemeMatches) {
                            this._requestMode = XDR;
                        }
                        else if (env.useXDR &amp;&amp; ! schemeMatches) {
                            if (cfg.allowFail) {
                                if (this.alertOnRequestFailure) {
                                    alert(&quot;[warning] LRS invalid: cross domain request for differing scheme in IE with XDR&quot;);
                                }
                            }
                            else {
                                if (this.alertOnRequestFailure) {
                                    alert(&quot;[error] LRS invalid: cross domain request for differing scheme in IE with XDR&quot;);
                                }
                                throw {
                                    code: 2,
                                    mesg: &quot;LRS invalid: cross domain request for differing scheme in IE with XDR&quot;
                                };
                            }
                        }
                    }
                    else {
                        if (cfg.allowFail) {
                            if (this.alertOnRequestFailure) {
                                alert(&quot;[warning] LRS invalid: cross domain requests not supported in this browser&quot;);
                            }
                        }
                        else {
                            if (this.alertOnRequestFailure) {
                                alert(&quot;[error] LRS invalid: cross domain requests not supported in this browser&quot;);
                            }
                            throw {
                                code: 2,
                                mesg: &quot;LRS invalid: cross domain requests not supported in this browser&quot;
                            };
                        }
                    }
                }
            }
            else {
                this.log(&quot;Unrecognized environment not supported: &quot; + env);
            }

            if (typeof cfg.version !== &quot;undefined&quot;) {
                this.log(&quot;version: &quot; + cfg.version);
                this.version = cfg.version;
            }
            else {
                &#x2F;&#x2F;
                &#x2F;&#x2F; assume max supported when not specified,
                &#x2F;&#x2F; TODO: add detection of LRS from call to endpoint
                &#x2F;&#x2F;
                this.version = TinCan.versions()[0];
            }
        },

        &#x2F;**
        Method used to send a request via browser objects to the LRS

        @method sendRequest
        @param {Object} [cfg] Configuration for request
            @param {String} [cfg.url] URL portion to add to endpoint
            @param {String} [cfg.method] GET, PUT, POST, etc.
            @param {Object} [cfg.params] Parameters to set on the querystring
            @param {String} [cfg.data] String of body content
            @param {Object} [cfg.headers] Additional headers to set in the request
            @param {Function} [cfg.callback] Function to run at completion
                @param {String|Null} cfg.callback.err If an error occurred, this parameter will contain the HTTP status code.
                    If the operation succeeded, err will be null.
                @param {Object} cfg.callback.xhr XHR object
            @param {Boolean} [cfg.ignore404] Whether 404 status codes should be considered an error
        @return {Object} XHR if called in a synchronous way (in other words no callback)
        *&#x2F;
        sendRequest: function (cfg) {
            this.log(&quot;sendRequest&quot;);
            var xhr,
                finished = false,
                location = window.location,
                fullUrl = this.endpoint + cfg.url,
                headers = {},
                data,
                requestCompleteResult,
                until,
                prop,
                pairs = [],
                self = this
            ;

            &#x2F;&#x2F; respect absolute URLs passed in
            if (cfg.url.indexOf(&quot;http&quot;) === 0) {
                fullUrl = cfg.url;
            }

            &#x2F;&#x2F; add extended LMS-specified values to the params
            if (this.extended !== null) {
                cfg.params = cfg.params || {};

                for (prop in this.extended) {
                    if (this.extended.hasOwnProperty(prop)) {
                        &#x2F;&#x2F; don&#x27;t overwrite cfg.params values that have already been added to the request with our extended params
                        if (! cfg.params.hasOwnProperty(prop)) {
                            if (this.extended[prop] !== null) {
                                cfg.params[prop] = this.extended[prop];
                            }
                        }
                    }
                }
            }

            &#x2F;&#x2F; consolidate headers
            headers[&quot;Content-Type&quot;] = &quot;application&#x2F;json&quot;;
            headers.Authorization = this.auth;
            if (this.version !== &quot;0.9&quot;) {
                headers[&quot;X-Experience-API-Version&quot;] = this.version;
            }

            for (prop in cfg.headers) {
                if (cfg.headers.hasOwnProperty(prop)) {
                    headers[prop] = cfg.headers[prop];
                }
            }

            if (this._requestMode === NATIVE) {
                this.log(&quot;sendRequest using XMLHttpRequest&quot;);

                for (prop in cfg.params) {
                    if (cfg.params.hasOwnProperty(prop)) {
                        pairs.push(prop + &quot;=&quot; + encodeURIComponent(cfg.params[prop]));
                    }
                }
                if (pairs.length &gt; 0) {
                    fullUrl += &quot;?&quot; + pairs.join(&quot;&amp;&quot;);
                }

                xhr = new XMLHttpRequest();
                xhr.open(cfg.method, fullUrl, (typeof cfg.callback !== &quot;undefined&quot;));
                for (prop in headers) {
                    if (headers.hasOwnProperty(prop)) {
                        xhr.setRequestHeader(prop, headers[prop]);
                    }
                }

                if (typeof cfg.data !== &quot;undefined&quot;) {
                    cfg.data += &quot;&quot;;
                }
                data = cfg.data;
            }
            else if (this._requestMode === XDR) {
                this.log(&quot;sendRequest using XDomainRequest&quot;);

                &#x2F;&#x2F; method has to go on querystring, and nothing else,
                &#x2F;&#x2F; and the actual method is then always POST
                fullUrl += &quot;?method=&quot; + cfg.method;

                &#x2F;&#x2F; params end up in the body
                for (prop in cfg.params) {
                    if (cfg.params.hasOwnProperty(prop)) {
                        pairs.push(prop + &quot;=&quot; + encodeURIComponent(cfg.params[prop]));
                    }
                }

                &#x2F;&#x2F; headers go into form data
                for (prop in headers) {
                    if (headers.hasOwnProperty(prop)) {
                        pairs.push(prop + &quot;=&quot; + encodeURIComponent(headers[prop]));
                    }
                }

                &#x2F;&#x2F; the original data is repackaged as &quot;content&quot; form var
                if (cfg.data !== null) {
                    pairs.push(&quot;content=&quot; + encodeURIComponent(cfg.data));
                }

                data = pairs.join(&quot;&amp;&quot;);

                xhr = new XDomainRequest ();
                xhr.open(&quot;POST&quot;, fullUrl);
            }
            else {
                this.log(&quot;sendRequest unrecognized _requestMode: &quot; + this._requestMode);
            }

            &#x2F;&#x2F; Setup request callback
            function requestComplete () {
                self.log(&quot;requestComplete: &quot; + finished + &quot;, xhr.status: &quot; + xhr.status);
                var notFoundOk,
                    httpStatus;

                &#x2F;&#x2F;
                &#x2F;&#x2F; older versions of IE don&#x27;t properly handle 204 status codes
                &#x2F;&#x2F; so correct when receiving a 1223 to be 204 locally
                &#x2F;&#x2F; http:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;10046972&#x2F;msie-returns-status-code-of-1223-for-ajax-request
                &#x2F;&#x2F;
                httpStatus = (xhr.status === 1223) ? 204 : xhr.status;

                if (! finished) {
                    &#x2F;&#x2F; may be in sync or async mode, using XMLHttpRequest or IE XDomainRequest, onreadystatechange or
                    &#x2F;&#x2F; onload or both might fire depending upon browser, just covering all bases with event hooks and
                    &#x2F;&#x2F; using &#x27;finished&#x27; flag to avoid triggering events multiple times
                    finished = true;

                    notFoundOk = (cfg.ignore404 &amp;&amp; httpStatus === 404);
                    if (httpStatus === undefined || (httpStatus &gt;= 200 &amp;&amp; httpStatus &lt; 400) || notFoundOk) {
                        if (cfg.callback) {
                            cfg.callback(null, xhr);
                        }
                        else {
                            requestCompleteResult = {
                                err: null,
                                xhr: xhr
                            };
                            return requestCompleteResult;
                        }
                    }
                    else {
                        &#x2F;&#x2F; Alert all errors except cancelled XHR requests
                        if (httpStatus &gt; 0) {
                            requestCompleteResult = {
                                err: httpStatus,
                                xhr: xhr
                            };
                            if (self.alertOnRequestFailure) {
                                alert(&quot;[warning] There was a problem communicating with the Learning Record Store. (&quot; + httpStatus + &quot; | &quot; + xhr.responseText+ &quot;)&quot;);
                            }
                            if (cfg.callback) {
                                cfg.callback(httpStatus, xhr);
                            }
                        }
                        return requestCompleteResult;
                    }
                }
                else {
                    return requestCompleteResult;
                }
            }

            xhr.onreadystatechange = function () {
                if (xhr.readyState === 4) {
                    requestComplete();
                }
            };

            xhr.onload = requestComplete;
            xhr.onerror = requestComplete;

            xhr.send(data);

            if (! cfg.callback) {
                &#x2F;&#x2F; synchronous
                if (this._requestMode === XDR) {
                    &#x2F;&#x2F; synchronous call in IE, with no synchronous mode available
                    until = 1000 + Date.now();
                    this.log(&quot;sendRequest - until: &quot; + until + &quot;, finished: &quot; + finished);

                    while (Date.now() &lt; until &amp;&amp; ! finished) {
                        &#x2F;&#x2F;this.log(&quot;calling __delay&quot;);
                        this.__delay();
                    }
                }
                return requestComplete();
            }

            &#x2F;&#x2F;
            &#x2F;&#x2F; for async requests give them the XHR object directly
            &#x2F;&#x2F; as the return value, the actual stuff they should be
            &#x2F;&#x2F; caring about is params to the callback, for sync
            &#x2F;&#x2F; requests they got the return value above
            &#x2F;&#x2F;
            return xhr;
        },

        &#x2F;**
        Save a statement, when used from a browser sends to the endpoint using the RESTful interface.
        Use a callback to make the call asynchronous.

        @method saveStatement
        @param {Object} TinCan.Statement to send
        @param {Object} [cfg] Configuration used when saving
            @param {Function} [cfg.callback] Callback to execute on completion
        *&#x2F;
        saveStatement: function (stmt, cfg) {
            this.log(&quot;saveStatement&quot;);
            var requestCfg;

            &#x2F;&#x2F; TODO: it would be better to make a subclass that knows
            &#x2F;&#x2F;       its own environment and just implements the protocol
            &#x2F;&#x2F;       that it needs to
            if (! TinCan.environment().isBrowser) {
                this.log(&quot;error: environment not implemented&quot;);
                return;
            }

            requestCfg = {
                url: &quot;statements&quot;,
                method: &quot;PUT&quot;,
                params: {
                    statementId: stmt.id
                },
                data: JSON.stringify(stmt.asVersion( this.version ))
            };
            if (typeof cfg.callback !== &quot;undefined&quot;) {
                requestCfg.callback = cfg.callback;
            }

            return this.sendRequest(requestCfg);
        },

        &#x2F;**
        Retrieve a statement, when used from a browser sends to the endpoint using the RESTful interface.

        @method retrieveStatement
        @param {String} ID of statement to retrieve
        @param {Object} [cfg] Configuration options
            @param {Function} [cfg.callback] Callback to execute on completion
        @return {Object} TinCan.Statement retrieved
        *&#x2F;
        retrieveStatement: function (stmtId, cfg) {
            this.log(&quot;retrieveStatement&quot;);
            var requestCfg,
                requestResult,
                callbackWrapper;

            &#x2F;&#x2F; TODO: it would be better to make a subclass that knows
            &#x2F;&#x2F;       its own environment and just implements the protocol
            &#x2F;&#x2F;       that it needs to
            if (! TinCan.environment().isBrowser) {
                this.log(&quot;error: environment not implemented&quot;);
                return;
            }

            requestCfg = {
                url: &quot;statements&quot;,
                method: &quot;GET&quot;,
                params: {
                    statementId: stmtId
                }
            };
            if (typeof cfg.callback !== &quot;undefined&quot;) {
                callbackWrapper = function (err, xhr) {
                    var result = xhr;

                    if (err === null) {
                        result = TinCan.Statement.fromJSON(xhr.responseText);
                    }

                    cfg.callback(err, result);
                };
                requestCfg.callback = callbackWrapper;
            }

            requestResult = this.sendRequest(requestCfg);
            if (! callbackWrapper) {
                requestResult.statement = null;
                if (requestResult.err === null) {
                    requestResult.statement = TinCan.Statement.fromJSON(requestResult.xhr.responseText);
                }
            }

            return requestResult;
        },

        &#x2F;**
        Save a set of statements, when used from a browser sends to the endpoint using the RESTful interface.
        Use a callback to make the call asynchronous.

        @method saveStatements
        @param {Array} Array of statements or objects convertable to statements
        @param {Object} [cfg] Configuration used when saving
            @param {Function} [cfg.callback] Callback to execute on completion
        *&#x2F;
        saveStatements: function (stmts, cfg) {
            this.log(&quot;saveStatements&quot;);
            var versionedStatements = [],
                requestCfg,
                i
            ;

            &#x2F;&#x2F; TODO: it would be better to make a subclass that knows
            &#x2F;&#x2F;       its own environment and just implements the protocol
            &#x2F;&#x2F;       that it needs to
            if (! TinCan.environment().isBrowser) {
                this.log(&quot;error: environment not implemented&quot;);
                return;
            }

            cfg = cfg || {};

            if (stmts.length &gt; 0) {
                for (i = 0; i &lt; stmts.length; i += 1) {
                    versionedStatements.push(
                        stmts[i].asVersion( this.version )
                    );
                }

                requestCfg = {
                    url: &quot;statements&quot;,
                    method: &quot;POST&quot;,
                    data: JSON.stringify(versionedStatements)
                };
                if (typeof cfg.callback !== &quot;undefined&quot;) {
                    requestCfg.callback = cfg.callback;
                }

                return this.sendRequest(requestCfg);
            }
        },

        &#x2F;**
        Fetch a set of statements, when used from a browser sends to the endpoint using the
        RESTful interface.  Use a callback to make the call asynchronous.

        @method queryStatements
        @param {Object} [cfg] Configuration used to query
            @param {Object} [cfg.params] Query parameters
                @param {TinCan.Agent} [cfg.params.actor] Agent matches &#x27;actor&#x27;
                @param {TinCan.Verb} [cfg.params.verb] Verb to query on
                @param {TinCan.Activity|TinCan.Agent|TinCan.Statement} [cfg.params.target] Activity, Agent, or Statement matches &#x27;object&#x27;
                @param {TinCan.Agent} [cfg.params.instructor] Agent matches &#x27;context:instructor&#x27;
                @param {String} [cfg.params.registration] Registration UUID
                @param {Boolean} [cfg.params.context] When filtering on target, include statements with matching context
                @param {String} [cfg.params.since] Match statements stored since specified timestamp
                @param {String} [cfg.params.until] Match statements stored at or before specified timestamp
                @param {Integer} [cfg.params.limit] Number of results to retrieve
                @param {Boolean} [cfg.params.authoritative] Get authoritative results
                @param {Boolean} [cfg.params.sparse] Get sparse results
                @param {Boolean} [cfg.params.ascending] Return results in ascending order of stored time
            @param {Function} [cfg.callback] Callback to execute on completion
                @param {String|null} cfg.callback.err Error status or null if succcess
                @param {TinCan.StatementsResult|XHR} cfg.callback.response Receives a StatementsResult argument
        @return {Object} Request result
        *&#x2F;
        queryStatements: function (cfg) {
            this.log(&quot;queryStatements&quot;);
            var requestCfg,
                requestResult,
                callbackWrapper;

            &#x2F;&#x2F; TODO: it would be better to make a subclass that knows
            &#x2F;&#x2F;       its own environment and just implements the protocol
            &#x2F;&#x2F;       that it needs to
            if (! TinCan.environment().isBrowser) {
                this.log(&quot;error: environment not implemented&quot;);
                return;
            }

            cfg = cfg || {};
            cfg.params = cfg.params || {};

            if (cfg.params.hasOwnProperty(&quot;target&quot;)) {
                cfg.params.object = cfg.params.target;
            }

            requestCfg = this._queryStatementsRequestCfg(cfg);

            if (typeof cfg.callback !== &quot;undefined&quot;) {
                callbackWrapper = function (err, xhr) {
                    var result = xhr;

                    if (err === null) {
                        result = TinCan.StatementsResult.fromJSON(xhr.responseText);
                    }

                    cfg.callback(err, result);
                };
                requestCfg.callback = callbackWrapper;
            }

            requestResult = this.sendRequest(requestCfg);
            requestResult.config = requestCfg;

            if (! callbackWrapper) {
                requestResult.statementsResult = null;
                if (requestResult.err === null) {
                    requestResult.statementsResult = TinCan.StatementsResult.fromJSON(requestResult.xhr.responseText);
                }
            }

            return requestResult;
        },

        &#x2F;**
        Build a request config object that can be passed to sendRequest() to make a query request

        @method _queryStatementsRequestCfg
        @private
        @param {Object} [cfg] See configuration for {{#crossLink &quot;TinCan.LRS&#x2F;queryStatements&quot;}}{{&#x2F;crossLink}}
        @return {Object} Request configuration object
        *&#x2F;
        _queryStatementsRequestCfg: function (cfg) {
            this.log(&quot;_queryStatementsRequestCfg&quot;);
            var params = {},
                returnCfg = {
                    url: &quot;statements&quot;,
                    method: &quot;GET&quot;,
                    params: params
                },
                jsonProps = [
                    &quot;actor&quot;,
                    &quot;object&quot;,
                    &quot;instructor&quot;
                ],
                idProps = [&quot;verb&quot;],
                valProps = [
                    &quot;registration&quot;,
                    &quot;context&quot;,
                    &quot;since&quot;,
                    &quot;until&quot;,
                    &quot;limit&quot;,
                    &quot;authoritative&quot;,
                    &quot;sparse&quot;,
                    &quot;ascending&quot;
                ],
                i;

            for (i = 0; i &lt; jsonProps.length; i += 1) {
                if (typeof cfg.params[jsonProps[i]] !== &quot;undefined&quot;) {
                    params[jsonProps[i]] = JSON.stringify(cfg.params[jsonProps[i]].asVersion(this.version));
                }
            }

            for (i = 0; i &lt; idProps.length; i += 1) {
                if (typeof cfg.params[idProps[i]] !== &quot;undefined&quot;) {
                    params[idProps[i]] = cfg.params[idProps[i]].id;
                }
            }

            for (i = 0; i &lt; valProps.length; i += 1) {
                if (typeof cfg.params[valProps[i]] !== &quot;undefined&quot;) {
                    params[valProps[i]] = cfg.params[valProps[i]];
                }
            }

            return returnCfg;
        },

        &#x2F;**
        Fetch more statements from a previous query, when used from a browser sends to the endpoint using the
        RESTful interface.  Use a callback to make the call asynchronous.

        @method moreStatements
        @param {Object} [cfg] Configuration used to query
            @param {String} [cfg.url] More URL
            @param {Function} [cfg.callback] Callback to execute on completion
                @param {String|null} cfg.callback.err Error status or null if succcess
                @param {TinCan.StatementsResult|XHR} cfg.callback.response Receives a StatementsResult argument
        @return {Object} Request result
        *&#x2F;
        moreStatements: function (cfg) {
            this.log(&quot;moreStatements: &quot; + cfg.url);
            var requestCfg,
                requestResult,
                callbackWrapper,
                parsedURL,
                serverRoot;

            &#x2F;&#x2F; TODO: it would be better to make a subclass that knows
            &#x2F;&#x2F;       its own environment and just implements the protocol
            &#x2F;&#x2F;       that it needs to
            if (! TinCan.environment().isBrowser) {
                this.log(&quot;error: environment not implemented&quot;);
                return;
            }

            cfg = cfg || {};

            &#x2F;&#x2F; to support our interface (to support IE) we need to break apart
            &#x2F;&#x2F; the more URL query params so that the request can be made properly later
            parsedURL = TinCan.Utils.parseURL(cfg.url);

            &#x2F;&#x2F;Respect a more URL that is relative to either the server root 
            &#x2F;&#x2F;or endpoint (though only the former is allowed in the spec)
            serverRoot = TinCan.Utils.getServerRoot(this.endpoint);
            if (parsedURL.path.indexOf(&quot;&#x2F;statements&quot;) === 0){
                parsedURL.path = this.endpoint.replace(serverRoot, &#x27;&#x27;) + parsedURL.path;
                this.log(&quot;converting non-standard more URL to &quot; + parsedURL.path);
            }

            &#x2F;&#x2F;The more relative URL might not start with a slash, add it if not
            if (parsedURL.path.indexOf(&quot;&#x2F;&quot;) !== 0) {
                parsedURL.path = &quot;&#x2F;&quot; + parsedURL.path;
            }

            requestCfg = {
                method: &quot;GET&quot;,
                &#x2F;&#x2F;For arbitrary more URLs to work, 
                &#x2F;&#x2F;we need to make the URL absolute here
                url: serverRoot + parsedURL.path,
                params: parsedURL.params
            };
            if (typeof cfg.callback !== &quot;undefined&quot;) {
                callbackWrapper = function (err, xhr) {
                    var result = xhr;

                    if (err === null) {
                        result = TinCan.StatementsResult.fromJSON(xhr.responseText);
                    }

                    cfg.callback(err, result);
                };
                requestCfg.callback = callbackWrapper;
            }

            requestResult = this.sendRequest(requestCfg);
            requestResult.config = requestCfg;

            if (! callbackWrapper) {
                requestResult.statementsResult = null;
                if (requestResult.err === null) {
                    requestResult.statementsResult = TinCan.StatementsResult.fromJSON(requestResult.xhr.responseText);
                }
            }

            return requestResult;
        },

        &#x2F;**
        Retrieve a state value, when used from a browser sends to the endpoint using the RESTful interface.

        @method retrieveState
        @param {String} key Key of state to retrieve
        @param {Object} cfg Configuration options
            @param {Object} cfg.activity TinCan.Activity
            @param {Object} cfg.agent TinCan.Agent
            @param {String} [cfg.registration] Registration
            @param {Function} [cfg.callback] Callback to execute on completion
                @param {Object|Null} cfg.callback.error
                @param {TinCan.State|null} cfg.callback.result null if state is 404
        @return {Object} TinCan.State retrieved when synchronous, or result from sendRequest
        *&#x2F;
        retrieveState: function (key, cfg) {
            this.log(&quot;retrieveState&quot;);
            var requestParams = {},
                requestCfg = {},
                requestResult,
                callbackWrapper
            ;

            &#x2F;&#x2F; TODO: it would be better to make a subclass that knows
            &#x2F;&#x2F;       its own environment and just implements the protocol
            &#x2F;&#x2F;       that it needs to
            if (! TinCan.environment().isBrowser) {
                this.log(&quot;error: environment not implemented&quot;);
                return;
            }

            requestParams = {
                stateId: key,
                activityId: cfg.activity.id
            };
            if (this.version === &quot;0.9&quot;) {
                requestParams.actor = JSON.stringify(cfg.agent.asVersion(this.version));
            }
            else {
                requestParams.agent = JSON.stringify(cfg.agent.asVersion(this.version));
            }
            if (typeof cfg.registration !== &quot;undefined&quot;) {
                if (this.version === &quot;0.9&quot;) {
                    requestParams.registrationId = cfg.registration;
                }
                else {
                    requestParams.registration = cfg.registration;
                }
            }

            requestCfg = {
                url: &quot;activities&#x2F;state&quot;,
                method: &quot;GET&quot;,
                params: requestParams,
                ignore404: true
            };
            if (typeof cfg.callback !== &quot;undefined&quot;) {
                callbackWrapper = function (err, xhr) {
                    var result = xhr;

                    if (err === null) {
                        if (xhr.status === 404) {
                            result = null;
                        }
                        else {
                            result = new TinCan.State(
                                {
                                    id: key,
                                    contents: xhr.responseText
                                }
                            );
                            if (typeof xhr.getResponseHeader !== &quot;undefined&quot; &amp;&amp; xhr.getResponseHeader(&quot;ETag&quot;) !== null &amp;&amp; xhr.getResponseHeader(&quot;ETag&quot;) !== &quot;&quot;) {
                                result.etag = xhr.getResponseHeader(&quot;ETag&quot;);
                            } else {
                                &#x2F;&#x2F;
                                &#x2F;&#x2F; either XHR didn&#x27;t have getResponseHeader (probably cause it is an IE
                                &#x2F;&#x2F; XDomainRequest object which doesn&#x27;t) or not populated by LRS so create
                                &#x2F;&#x2F; the hash ourselves
                                &#x2F;&#x2F;
                                result.etag = TinCan.Utils.getSHA1String(xhr.responseText);
                            }
                        }
                    }

                    cfg.callback(err, result);
                };
                requestCfg.callback = callbackWrapper;
            }

            requestResult = this.sendRequest(requestCfg);
            if (! callbackWrapper) {
                requestResult.state = null;
                if (requestResult.err === null &amp;&amp; requestResult.xhr.status !== 404) {
                    requestResult.state = new TinCan.State(
                        {
                            id: key,
                            contents: requestResult.xhr.responseText
                        }
                    );
                    if (typeof requestResult.xhr.getResponseHeader !== &quot;undefined&quot; &amp;&amp; requestResult.xhr.getResponseHeader(&quot;ETag&quot;) !== null &amp;&amp; requestResult.xhr.getResponseHeader(&quot;ETag&quot;) !== &quot;&quot;) {
                        requestResult.state.etag = requestResult.xhr.getResponseHeader(&quot;ETag&quot;);
                    } else {
                        &#x2F;&#x2F;
                        &#x2F;&#x2F; either XHR didn&#x27;t have getResponseHeader (probably cause it is an IE
                        &#x2F;&#x2F; XDomainRequest object which doesn&#x27;t) or not populated by LRS so create
                        &#x2F;&#x2F; the hash ourselves
                        &#x2F;&#x2F;
                        requestResult.state.etag = TinCan.Utils.getSHA1String(requestResult.xhr.responseText);
                    }
                }
            }

            return requestResult;
        },

        &#x2F;**
        Save a state value, when used from a browser sends to the endpoint using the RESTful interface.

        @method saveState
        @param {String} key Key of state to save
        @param {String} val Value of state to save
        @param {Object} cfg Configuration options
            @param {Object} cfg.activity TinCan.Activity
            @param {Object} cfg.agent TinCan.Agent
            @param {String} [cfg.registration] Registration
            @param {String} [cfg.lastSHA1] SHA1 of the previously seen existing state
            @param {Function} [cfg.callback] Callback to execute on completion
        *&#x2F;
        saveState: function (key, val, cfg) {
            this.log(&quot;saveState&quot;);
            var requestParams,
                requestCfg,
                requestResult
            ;

            &#x2F;&#x2F; TODO: it would be better to make a subclass that knows
            &#x2F;&#x2F;       its own environment and just implements the protocol
            &#x2F;&#x2F;       that it needs to
            if (! TinCan.environment().isBrowser) {
                this.log(&quot;error: environment not implemented&quot;);
                return;
            }

            if (typeof val === &quot;object&quot;) {
                val = JSON.stringify(val);
            }

            requestParams = {
                stateId: key,
                activityId: cfg.activity.id
            };
            if (this.version === &quot;0.9&quot;) {
                requestParams.actor = JSON.stringify(cfg.agent.asVersion(this.version));
            }
            else {
                requestParams.agent = JSON.stringify(cfg.agent.asVersion(this.version));
            }
            if (typeof cfg.registration !== &quot;undefined&quot;) {
                if (this.version === &quot;0.9&quot;) {
                    requestParams.registrationId = cfg.registration;
                }
                else {
                    requestParams.registration = cfg.registration;
                }
            }

            requestCfg = {
                url: &quot;activities&#x2F;state&quot;,
                method: &quot;PUT&quot;,
                params: requestParams,
                data: val
            };
            if (typeof cfg.callback !== &quot;undefined&quot;) {
                requestCfg.callback = cfg.callback;
            }
            if (typeof cfg.lastSHA1 !== &quot;undefined&quot; &amp;&amp; cfg.lastSHA1 !== null) {
                requestCfg.headers = {
                    &quot;If-Matches&quot;: cfg.lastSHA1
                };
            }

            return this.sendRequest(requestCfg);
        },

        &#x2F;**
        Drop a state value or all of the state, when used from a browser sends to the endpoint using the RESTful interface.

        @method dropState
        @param {String|null} key Key of state to delete, or null for all
        @param {Object} cfg Configuration options
            @param {Object} [cfg.activity] TinCan.Activity
            @param {Object} [cfg.agent] TinCan.Agent
            @param {String} [cfg.registration] Registration
            @param {Function} [cfg.callback] Callback to execute on completion
        *&#x2F;
        dropState: function (key, cfg) {
            this.log(&quot;dropState&quot;);
            var requestParams = {},
                requestCfg = {}
            ;

            &#x2F;&#x2F; TODO: it would be better to make a subclass that knows
            &#x2F;&#x2F;       its own environment and just implements the protocol
            &#x2F;&#x2F;       that it needs to
            if (! TinCan.environment().isBrowser) {
                this.log(&quot;error: environment not implemented&quot;);
                return;
            }

            requestParams = {
                activityId: cfg.activity.id
            };
            if (this.version === &quot;0.9&quot;) {
                requestParams.actor = JSON.stringify(cfg.agent.asVersion(this.version));
            }
            else {
                requestParams.agent = JSON.stringify(cfg.agent.asVersion(this.version));
            }
            if (key !== null) {
                requestParams.stateId = key;
            }
            if (typeof cfg.registration !== &quot;undefined&quot;) {
                if (this.version === &quot;0.9&quot;) {
                    requestParams.registrationId = cfg.registration;
                }
                else {
                    requestParams.registration = cfg.registration;
                }
            }

            requestCfg = {
                url: &quot;activities&#x2F;state&quot;,
                method: &quot;DELETE&quot;,
                params: requestParams
            };
            if (typeof cfg.callback !== &quot;undefined&quot;) {
                requestCfg.callback = cfg.callback;
            }

            return this.sendRequest(requestCfg);
        },

        &#x2F;**
        Retrieve an activity profile value, when used from a browser sends to the endpoint using the RESTful interface.

        @method retrieveActivityProfile
        @param {String} key Key of activity profile to retrieve
        @param {Object} cfg Configuration options
            @param {Object} cfg.activity TinCan.Activity
            @param {Function} [cfg.callback] Callback to execute on completion
        @return {Object} Value retrieved
        *&#x2F;
        retrieveActivityProfile: function (key, cfg) {
            this.log(&quot;retrieveActivityProfile&quot;);
            var requestCfg = {},
                requestResult,
                callbackWrapper
            ;

            &#x2F;&#x2F; TODO: it would be better to make a subclass that knows
            &#x2F;&#x2F;       its own environment and just implements the protocol
            &#x2F;&#x2F;       that it needs to
            if (! TinCan.environment().isBrowser) {
                this.log(&quot;error: environment not implemented&quot;);
                return;
            }

            requestCfg = {
                url: &quot;activities&#x2F;profile&quot;,
                method: &quot;GET&quot;,
                params: {
                    profileId: key,
                    activityId: cfg.activity.id
                },
                ignore404: true
            };
            if (typeof cfg.callback !== &quot;undefined&quot;) {
                callbackWrapper = function (err, xhr) {
                    var result = xhr;

                    if (err === null) {
                        if (xhr.status === 404) {
                            result = null;
                        }
                        else {
                            result = new TinCan.ActivityProfile(
                                {
                                    id: key,
                                    activity: cfg.activity,
                                    contents: xhr.responseText
                                }
                            );
                            if (typeof xhr.getResponseHeader !== &quot;undefined&quot; &amp;&amp; xhr.getResponseHeader(&quot;ETag&quot;) !== null &amp;&amp; xhr.getResponseHeader(&quot;ETag&quot;) !== &quot;&quot;) {
                                result.etag = xhr.getResponseHeader(&quot;ETag&quot;);
                            } else {
                                &#x2F;&#x2F;
                                &#x2F;&#x2F; either XHR didn&#x27;t have getResponseHeader (probably cause it is an IE
                                &#x2F;&#x2F; XDomainRequest object which doesn&#x27;t) or not populated by LRS so create
                                &#x2F;&#x2F; the hash ourselves
                                &#x2F;&#x2F;
                                result.etag = TinCan.Utils.getSHA1String(xhr.responseText);
                            }
                        }
                    }

                    cfg.callback(err, result);
                };
                requestCfg.callback = callbackWrapper;
            }

            requestResult = this.sendRequest(requestCfg);
            if (! callbackWrapper) {
                requestResult.profile = null;
                if (requestResult.err === null &amp;&amp; requestResult.xhr.status !== 404) {
                    requestResult.profile = new TinCan.ActivityProfile(
                        {
                            id: key,
                            activity: cfg.activity,
                            contents: requestResult.xhr.responseText
                        }
                    );
                    if (typeof requestResult.xhr.getResponseHeader !== &quot;undefined&quot; &amp;&amp; requestResult.xhr.getResponseHeader(&quot;ETag&quot;) !== null &amp;&amp; requestResult.xhr.getResponseHeader(&quot;ETag&quot;) !== &quot;&quot;) {
                        requestResult.profile.etag = requestResult.xhr.getResponseHeader(&quot;ETag&quot;);
                    } else {
                        &#x2F;&#x2F;
                        &#x2F;&#x2F; either XHR didn&#x27;t have getResponseHeader (probably cause it is an IE
                        &#x2F;&#x2F; XDomainRequest object which doesn&#x27;t) or not populated by LRS so create
                        &#x2F;&#x2F; the hash ourselves
                        &#x2F;&#x2F;
                        requestResult.profile.etag = TinCan.Utils.getSHA1String(requestResult.xhr.responseText);
                    }
                }
            }

            return requestResult;
        },

        &#x2F;**
        Save an activity profile value, when used from a browser sends to the endpoint using the RESTful interface.

        @method saveActivityProfile
        @param {String} key Key of activity profile to retrieve
        @param {Object} cfg Configuration options
            @param {Object} cfg.activity TinCan.Activity
            @param {String} [cfg.lastSHA1] SHA1 of the previously seen existing profile
            @param {Function} [cfg.callback] Callback to execute on completion
        *&#x2F;
        saveActivityProfile: function (key, val, cfg) {
            this.log(&quot;saveActivityProfile&quot;);
            var requestCfg;

            &#x2F;&#x2F; TODO: it would be better to make a subclass that knows
            &#x2F;&#x2F;       its own environment and just implements the protocol
            &#x2F;&#x2F;       that it needs to
            if (! TinCan.environment().isBrowser) {
                this.log(&quot;error: environment not implemented&quot;);
                return;
            }

            if (typeof val === &quot;object&quot;) {
                val = JSON.stringify(val);
            }

            requestCfg = {
                url: &quot;activities&#x2F;profile&quot;,
                method: &quot;PUT&quot;,
                params: {
                    profileId: key,
                    activityId: cfg.activity.id
                },
                data: val
            };
            if (typeof cfg.callback !== &quot;undefined&quot;) {
                requestCfg.callback = cfg.callback;
            }
            if (typeof cfg.lastSHA1 !== &quot;undefined&quot; &amp;&amp; cfg.lastSHA1 !== null) {
                requestCfg.headers = {
                    &quot;If-Matches&quot;: cfg.lastSHA1
                };
            }

            return this.sendRequest(requestCfg);
        },

        &#x2F;**
        Drop an activity profile value or all of the activity profile, when used from a browser sends to the endpoint using the RESTful interface.

        @method dropActivityProfile
        @param {String|null} key Key of activity profile to delete, or null for all
        @param {Object} cfg Configuration options
            @param {Object} cfg.activity TinCan.Activity
            @param {Function} [cfg.callback] Callback to execute on completion
        *&#x2F;
        dropActivityProfile: function (key, cfg) {
            this.log(&quot;dropActivityProfile&quot;);
            var requestParams = {},
                requestCfg = {}
            ;

            &#x2F;&#x2F; TODO: it would be better to make a subclass that knows
            &#x2F;&#x2F;       its own environment and just implements the protocol
            &#x2F;&#x2F;       that it needs to
            if (! TinCan.environment().isBrowser) {
                this.log(&quot;error: environment not implemented&quot;);
                return;
            }

            requestParams = {
                activityId: cfg.activity.id
            };
            if (key !== null) {
                requestParams.profileId = key;
            }

            requestCfg = {
                url: &quot;activities&#x2F;profile&quot;,
                method: &quot;DELETE&quot;,
                params: requestParams
            };
            if (typeof cfg.callback !== &quot;undefined&quot;) {
                requestCfg.callback = cfg.callback;
            }

            return this.sendRequest(requestCfg);
        },

        &#x2F;**
        Non-environment safe method used to create a delay to give impression
        of synchronous response

        @method __delay
        @private
        *&#x2F;
        __delay: function () {
            &#x2F;&#x2F;
            &#x2F;&#x2F; use a synchronous request to the current location to allow the browser
            &#x2F;&#x2F; to yield to the asynchronous request&#x27;s events but still block in the
            &#x2F;&#x2F; outer loop to make it seem synchronous to the end user
            &#x2F;&#x2F;
            &#x2F;&#x2F; removing this made the while loop too tight to allow the asynchronous
            &#x2F;&#x2F; events through to get handled so that the response was correctly handled
            &#x2F;&#x2F;
            var xhr = new XMLHttpRequest (),
                url = window.location + &quot;?forcenocache=&quot; + TinCan.Utils.getUUID()
            ;
            xhr.open(&quot;GET&quot;, url, false);
            xhr.send(null);
        }
    };
}());

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
